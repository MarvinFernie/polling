"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/polls/page",{

/***/ "(app-pages-browser)/./src/lib/db.ts":
/*!***********************!*\
  !*** ./src/lib/db.ts ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPoll: function() { return /* binding */ createPoll; },\n/* harmony export */   getPoll: function() { return /* binding */ getPoll; },\n/* harmony export */   getPolls: function() { return /* binding */ getPolls; },\n/* harmony export */   getUserVote: function() { return /* binding */ getUserVote; },\n/* harmony export */   hasUserUpvoted: function() { return /* binding */ hasUserUpvoted; },\n/* harmony export */   hasUserVoted: function() { return /* binding */ hasUserVoted; },\n/* harmony export */   upvotePoll: function() { return /* binding */ upvotePoll; },\n/* harmony export */   vote: function() { return /* binding */ vote; }\n/* harmony export */ });\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./src/lib/firebase.ts\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n\n\n// Collection references\nconst pollsCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"polls\");\nconst userVotesCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"userVotes\");\nconst userUpvotesCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"userUpvotes\");\n/**\n * Create a new poll\n */ async function createPoll(data) {\n    // Convert options to PollOption objects\n    const options = data.options.map((text)=>({\n            id: Math.random().toString(36).substring(2, 15),\n            text,\n            votes: 0\n        }));\n    // Create new poll document\n    const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)(pollsCollection, {\n        question: data.question,\n        options,\n        upvotes: 0,\n        createdAt: Date.now()\n    });\n    return docRef.id;\n}\n/**\n * Get a poll by ID\n */ async function getPoll(id) {\n    const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"polls\", id);\n    const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(docRef);\n    if (!docSnap.exists()) {\n        return null;\n    }\n    const data = docSnap.data();\n    return {\n        id: docSnap.id,\n        ...data\n    };\n}\n/**\n * Get polls for the feed, sorted by upvotes\n */ async function getPolls() {\n    let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 20;\n    try {\n        console.log(\"Querying Firestore for polls...\");\n        // Make sure db is initialized\n        if (!_firebase__WEBPACK_IMPORTED_MODULE_0__.db) {\n            console.error(\"Firestore db is not initialized\");\n            return [];\n        }\n        // Sort by creation time as fallback if no upvotes\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(pollsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"upvotes\", \"desc\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"), limit(limit));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        console.log(\"Found \".concat(querySnapshot.docs.length, \" polls\"));\n        // Map docs to Poll objects with proper type safety\n        return querySnapshot.docs.map((doc)=>{\n            const data = doc.data();\n            return {\n                id: doc.id,\n                question: data.question || \"\",\n                options: data.options || [],\n                upvotes: data.upvotes || 0,\n                createdAt: data.createdAt || Date.now()\n            };\n        });\n    } catch (error) {\n        console.error(\"Error getting polls:\", error);\n        return [];\n    }\n}\n/**\n * Vote on a poll option\n */ async function vote(userId, pollId, optionId) {\n    // Check if user has already voted on this poll\n    const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(userVotesCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"userId\", \"==\", userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"pollId\", \"==\", pollId));\n    const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n    if (!querySnapshot.empty) {\n        // User has already voted\n        return false;\n    }\n    // Get the poll document\n    const pollRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"polls\", pollId);\n    const pollSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(pollRef);\n    if (!pollSnap.exists()) {\n        return false;\n    }\n    const pollData = pollSnap.data();\n    const options = pollData.options;\n    // Find the option and update its votes\n    const optionIndex = options.findIndex((opt)=>opt.id === optionId);\n    if (optionIndex === -1) {\n        return false;\n    }\n    // Update the option's vote count\n    options[optionIndex].votes = options[optionIndex].votes + 1;\n    // Update the poll document\n    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(pollRef, {\n        options: options\n    });\n    // Record the user's vote\n    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)(userVotesCollection, {\n        userId,\n        pollId,\n        optionId,\n        votedAt: Date.now()\n    });\n    return true;\n}\n/**\n * Upvote a poll\n */ async function upvotePoll(userId, pollId) {\n    // Check if user has already upvoted this poll\n    const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(userUpvotesCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"userId\", \"==\", userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"pollId\", \"==\", pollId));\n    const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n    if (!querySnapshot.empty) {\n        // User has already upvoted\n        return false;\n    }\n    // Get the poll document\n    const pollRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"polls\", pollId);\n    const pollSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(pollRef);\n    if (!pollSnap.exists()) {\n        return false;\n    }\n    // Update the poll's upvote count\n    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(pollRef, {\n        upvotes: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.increment)(1)\n    });\n    // Record the user's upvote\n    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)(userUpvotesCollection, {\n        userId,\n        pollId,\n        upvotedAt: Date.now()\n    });\n    return true;\n}\n/**\n * Check if a user has voted on a poll\n */ async function hasUserVoted(userId, pollId) {\n    const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(userVotesCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"userId\", \"==\", userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"pollId\", \"==\", pollId));\n    const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n    return !querySnapshot.empty;\n}\n/**\n * Check if a user has upvoted a poll\n */ async function hasUserUpvoted(userId, pollId) {\n    const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(userUpvotesCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"userId\", \"==\", userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"pollId\", \"==\", pollId));\n    const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n    return !querySnapshot.empty;\n}\n/**\n * Get a user's vote for a poll\n */ async function getUserVote(userId, pollId) {\n    const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(userVotesCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"userId\", \"==\", userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"pollId\", \"==\", pollId));\n    const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n    if (querySnapshot.empty) {\n        return null;\n    }\n    const vote = querySnapshot.docs[0].data();\n    return vote.optionId;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWdCLE1BQU1uQywyREFBT0EsQ0FBQ2tDO0lBRXBDLElBQUlDLGNBQWNPLEtBQUssRUFBRTtRQUN2QixPQUFPO0lBQ1Q7SUFFQSxNQUFNSixPQUFPSCxjQUFjQyxJQUFJLENBQUMsRUFBRSxDQUFDMUIsSUFBSTtJQUN2QyxPQUFPNEIsS0FBS0csUUFBUTtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2RiLnRzPzllNGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGIgfSBmcm9tICcuL2ZpcmViYXNlJztcbmltcG9ydCB7XG4gIGNvbGxlY3Rpb24sXG4gIGRvYyxcbiAgYWRkRG9jLFxuICBnZXREb2MsXG4gIGdldERvY3MsXG4gIHVwZGF0ZURvYyxcbiAgcXVlcnksXG4gIHdoZXJlLFxuICBvcmRlckJ5LFxuICBpbmNyZW1lbnQsXG4gIGxpbWl0LFxuICBzZXJ2ZXJUaW1lc3RhbXAsXG4gIERvY3VtZW50UmVmZXJlbmNlLFxuICBEb2N1bWVudERhdGEsXG4gIFRpbWVzdGFtcCxcbn0gZnJvbSAnZmlyZWJhc2UvZmlyZXN0b3JlJztcbmltcG9ydCB7IFBvbGwsIENyZWF0ZVBvbGxEYXRhLCBQb2xsT3B0aW9uLCBVc2VyVm90ZSwgVXNlclVwdm90ZSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBDb2xsZWN0aW9uIHJlZmVyZW5jZXNcbmNvbnN0IHBvbGxzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24oZGIsICdwb2xscycpO1xuY29uc3QgdXNlclZvdGVzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24oZGIsICd1c2VyVm90ZXMnKTtcbmNvbnN0IHVzZXJVcHZvdGVzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24oZGIsICd1c2VyVXB2b3RlcycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBwb2xsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVQb2xsKGRhdGE6IENyZWF0ZVBvbGxEYXRhKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgLy8gQ29udmVydCBvcHRpb25zIHRvIFBvbGxPcHRpb24gb2JqZWN0c1xuICBjb25zdCBvcHRpb25zOiBQb2xsT3B0aW9uW10gPSBkYXRhLm9wdGlvbnMubWFwKCh0ZXh0KSA9PiAoe1xuICAgIGlkOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpLFxuICAgIHRleHQsXG4gICAgdm90ZXM6IDAsXG4gIH0pKTtcblxuICAvLyBDcmVhdGUgbmV3IHBvbGwgZG9jdW1lbnRcbiAgY29uc3QgZG9jUmVmID0gYXdhaXQgYWRkRG9jKHBvbGxzQ29sbGVjdGlvbiwge1xuICAgIHF1ZXN0aW9uOiBkYXRhLnF1ZXN0aW9uLFxuICAgIG9wdGlvbnMsXG4gICAgdXB2b3RlczogMCxcbiAgICBjcmVhdGVkQXQ6IERhdGUubm93KCksXG4gIH0pO1xuXG4gIHJldHVybiBkb2NSZWYuaWQ7XG59XG5cbi8qKlxuICogR2V0IGEgcG9sbCBieSBJRFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UG9sbChpZDogc3RyaW5nKTogUHJvbWlzZTxQb2xsIHwgbnVsbD4ge1xuICBjb25zdCBkb2NSZWYgPSBkb2MoZGIsICdwb2xscycsIGlkKTtcbiAgY29uc3QgZG9jU25hcCA9IGF3YWl0IGdldERvYyhkb2NSZWYpO1xuXG4gIGlmICghZG9jU25hcC5leGlzdHMoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZGF0YSA9IGRvY1NuYXAuZGF0YSgpO1xuICByZXR1cm4ge1xuICAgIGlkOiBkb2NTbmFwLmlkLFxuICAgIC4uLmRhdGEsXG4gIH0gYXMgUG9sbDtcbn1cblxuLyoqXG4gKiBHZXQgcG9sbHMgZm9yIHRoZSBmZWVkLCBzb3J0ZWQgYnkgdXB2b3Rlc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UG9sbHMobGltaXQ6IG51bWJlciA9IDIwKTogUHJvbWlzZTxQb2xsW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhcIlF1ZXJ5aW5nIEZpcmVzdG9yZSBmb3IgcG9sbHMuLi5cIik7XG4gICAgXG4gICAgLy8gTWFrZSBzdXJlIGRiIGlzIGluaXRpYWxpemVkXG4gICAgaWYgKCFkYikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZpcmVzdG9yZSBkYiBpcyBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIC8vIFNvcnQgYnkgY3JlYXRpb24gdGltZSBhcyBmYWxsYmFjayBpZiBubyB1cHZvdGVzXG4gICAgY29uc3QgcSA9IHF1ZXJ5KFxuICAgICAgcG9sbHNDb2xsZWN0aW9uLCBcbiAgICAgIG9yZGVyQnkoJ3Vwdm90ZXMnLCAnZGVzYycpLCBcbiAgICAgIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJyksIFxuICAgICAgbGltaXQobGltaXQpXG4gICAgKTtcbiAgICBcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtxdWVyeVNuYXBzaG90LmRvY3MubGVuZ3RofSBwb2xsc2ApO1xuICAgIFxuICAgIC8vIE1hcCBkb2NzIHRvIFBvbGwgb2JqZWN0cyB3aXRoIHByb3BlciB0eXBlIHNhZmV0eVxuICAgIHJldHVybiBxdWVyeVNuYXBzaG90LmRvY3MubWFwKChkb2MpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgICAgcXVlc3Rpb246IGRhdGEucXVlc3Rpb24gfHwgXCJcIixcbiAgICAgICAgb3B0aW9uczogZGF0YS5vcHRpb25zIHx8IFtdLFxuICAgICAgICB1cHZvdGVzOiBkYXRhLnVwdm90ZXMgfHwgMCxcbiAgICAgICAgY3JlYXRlZEF0OiBkYXRhLmNyZWF0ZWRBdCB8fCBEYXRlLm5vdygpLFxuICAgICAgfSBhcyBQb2xsO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIHBvbGxzOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qKlxuICogVm90ZSBvbiBhIHBvbGwgb3B0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2b3RlKFxuICB1c2VySWQ6IHN0cmluZyxcbiAgcG9sbElkOiBzdHJpbmcsXG4gIG9wdGlvbklkOiBzdHJpbmdcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAvLyBDaGVjayBpZiB1c2VyIGhhcyBhbHJlYWR5IHZvdGVkIG9uIHRoaXMgcG9sbFxuICBjb25zdCBxID0gcXVlcnkoXG4gICAgdXNlclZvdGVzQ29sbGVjdGlvbixcbiAgICB3aGVyZSgndXNlcklkJywgJz09JywgdXNlcklkKSxcbiAgICB3aGVyZSgncG9sbElkJywgJz09JywgcG9sbElkKVxuICApO1xuICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcblxuICBpZiAoIXF1ZXJ5U25hcHNob3QuZW1wdHkpIHtcbiAgICAvLyBVc2VyIGhhcyBhbHJlYWR5IHZvdGVkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBwb2xsIGRvY3VtZW50XG4gIGNvbnN0IHBvbGxSZWYgPSBkb2MoZGIsICdwb2xscycsIHBvbGxJZCk7XG4gIGNvbnN0IHBvbGxTbmFwID0gYXdhaXQgZ2V0RG9jKHBvbGxSZWYpO1xuXG4gIGlmICghcG9sbFNuYXAuZXhpc3RzKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBwb2xsRGF0YSA9IHBvbGxTbmFwLmRhdGEoKSBhcyBQb2xsO1xuICBjb25zdCBvcHRpb25zID0gcG9sbERhdGEub3B0aW9ucztcblxuICAvLyBGaW5kIHRoZSBvcHRpb24gYW5kIHVwZGF0ZSBpdHMgdm90ZXNcbiAgY29uc3Qgb3B0aW9uSW5kZXggPSBvcHRpb25zLmZpbmRJbmRleCgob3B0KSA9PiBvcHQuaWQgPT09IG9wdGlvbklkKTtcbiAgaWYgKG9wdGlvbkluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgb3B0aW9uJ3Mgdm90ZSBjb3VudFxuICBvcHRpb25zW29wdGlvbkluZGV4XS52b3RlcyA9IG9wdGlvbnNbb3B0aW9uSW5kZXhdLnZvdGVzICsgMTtcblxuICAvLyBVcGRhdGUgdGhlIHBvbGwgZG9jdW1lbnRcbiAgYXdhaXQgdXBkYXRlRG9jKHBvbGxSZWYsIHtcbiAgICBvcHRpb25zOiBvcHRpb25zLFxuICB9KTtcblxuICAvLyBSZWNvcmQgdGhlIHVzZXIncyB2b3RlXG4gIGF3YWl0IGFkZERvYyh1c2VyVm90ZXNDb2xsZWN0aW9uLCB7XG4gICAgdXNlcklkLFxuICAgIHBvbGxJZCxcbiAgICBvcHRpb25JZCxcbiAgICB2b3RlZEF0OiBEYXRlLm5vdygpLFxuICB9KTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVcHZvdGUgYSBwb2xsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cHZvdGVQb2xsKFxuICB1c2VySWQ6IHN0cmluZyxcbiAgcG9sbElkOiBzdHJpbmdcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAvLyBDaGVjayBpZiB1c2VyIGhhcyBhbHJlYWR5IHVwdm90ZWQgdGhpcyBwb2xsXG4gIGNvbnN0IHEgPSBxdWVyeShcbiAgICB1c2VyVXB2b3Rlc0NvbGxlY3Rpb24sXG4gICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXJJZCksXG4gICAgd2hlcmUoJ3BvbGxJZCcsICc9PScsIHBvbGxJZClcbiAgKTtcbiAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XG5cbiAgaWYgKCFxdWVyeVNuYXBzaG90LmVtcHR5KSB7XG4gICAgLy8gVXNlciBoYXMgYWxyZWFkeSB1cHZvdGVkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBwb2xsIGRvY3VtZW50XG4gIGNvbnN0IHBvbGxSZWYgPSBkb2MoZGIsICdwb2xscycsIHBvbGxJZCk7XG4gIGNvbnN0IHBvbGxTbmFwID0gYXdhaXQgZ2V0RG9jKHBvbGxSZWYpO1xuXG4gIGlmICghcG9sbFNuYXAuZXhpc3RzKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIHBvbGwncyB1cHZvdGUgY291bnRcbiAgYXdhaXQgdXBkYXRlRG9jKHBvbGxSZWYsIHtcbiAgICB1cHZvdGVzOiBpbmNyZW1lbnQoMSksXG4gIH0pO1xuXG4gIC8vIFJlY29yZCB0aGUgdXNlcidzIHVwdm90ZVxuICBhd2FpdCBhZGREb2ModXNlclVwdm90ZXNDb2xsZWN0aW9uLCB7XG4gICAgdXNlcklkLFxuICAgIHBvbGxJZCxcbiAgICB1cHZvdGVkQXQ6IERhdGUubm93KCksXG4gIH0pO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdXNlciBoYXMgdm90ZWQgb24gYSBwb2xsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYXNVc2VyVm90ZWQoXG4gIHVzZXJJZDogc3RyaW5nLFxuICBwb2xsSWQ6IHN0cmluZ1xuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IHEgPSBxdWVyeShcbiAgICB1c2VyVm90ZXNDb2xsZWN0aW9uLFxuICAgIHdoZXJlKCd1c2VySWQnLCAnPT0nLCB1c2VySWQpLFxuICAgIHdoZXJlKCdwb2xsSWQnLCAnPT0nLCBwb2xsSWQpXG4gICk7XG4gIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuXG4gIHJldHVybiAhcXVlcnlTbmFwc2hvdC5lbXB0eTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHVzZXIgaGFzIHVwdm90ZWQgYSBwb2xsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYXNVc2VyVXB2b3RlZChcbiAgdXNlcklkOiBzdHJpbmcsXG4gIHBvbGxJZDogc3RyaW5nXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgcSA9IHF1ZXJ5KFxuICAgIHVzZXJVcHZvdGVzQ29sbGVjdGlvbixcbiAgICB3aGVyZSgndXNlcklkJywgJz09JywgdXNlcklkKSxcbiAgICB3aGVyZSgncG9sbElkJywgJz09JywgcG9sbElkKVxuICApO1xuICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcblxuICByZXR1cm4gIXF1ZXJ5U25hcHNob3QuZW1wdHk7XG59XG5cbi8qKlxuICogR2V0IGEgdXNlcidzIHZvdGUgZm9yIGEgcG9sbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXNlclZvdGUoXG4gIHVzZXJJZDogc3RyaW5nLFxuICBwb2xsSWQ6IHN0cmluZ1xuKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIGNvbnN0IHEgPSBxdWVyeShcbiAgICB1c2VyVm90ZXNDb2xsZWN0aW9uLFxuICAgIHdoZXJlKCd1c2VySWQnLCAnPT0nLCB1c2VySWQpLFxuICAgIHdoZXJlKCdwb2xsSWQnLCAnPT0nLCBwb2xsSWQpXG4gICk7XG4gIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuXG4gIGlmIChxdWVyeVNuYXBzaG90LmVtcHR5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCB2b3RlID0gcXVlcnlTbmFwc2hvdC5kb2NzWzBdLmRhdGEoKSBhcyBVc2VyVm90ZTtcbiAgcmV0dXJuIHZvdGUub3B0aW9uSWQ7XG59Il0sIm5hbWVzIjpbImRiIiwiY29sbGVjdGlvbiIsImRvYyIsImFkZERvYyIsImdldERvYyIsImdldERvY3MiLCJ1cGRhdGVEb2MiLCJxdWVyeSIsIndoZXJlIiwib3JkZXJCeSIsImluY3JlbWVudCIsInBvbGxzQ29sbGVjdGlvbiIsInVzZXJWb3Rlc0NvbGxlY3Rpb24iLCJ1c2VyVXB2b3Rlc0NvbGxlY3Rpb24iLCJjcmVhdGVQb2xsIiwiZGF0YSIsIm9wdGlvbnMiLCJtYXAiLCJ0ZXh0IiwiaWQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJ2b3RlcyIsImRvY1JlZiIsInF1ZXN0aW9uIiwidXB2b3RlcyIsImNyZWF0ZWRBdCIsIkRhdGUiLCJub3ciLCJnZXRQb2xsIiwiZG9jU25hcCIsImV4aXN0cyIsImdldFBvbGxzIiwibGltaXQiLCJjb25zb2xlIiwibG9nIiwiZXJyb3IiLCJxIiwicXVlcnlTbmFwc2hvdCIsImRvY3MiLCJsZW5ndGgiLCJ2b3RlIiwidXNlcklkIiwicG9sbElkIiwib3B0aW9uSWQiLCJlbXB0eSIsInBvbGxSZWYiLCJwb2xsU25hcCIsInBvbGxEYXRhIiwib3B0aW9uSW5kZXgiLCJmaW5kSW5kZXgiLCJvcHQiLCJ2b3RlZEF0IiwidXB2b3RlUG9sbCIsInVwdm90ZWRBdCIsImhhc1VzZXJWb3RlZCIsImhhc1VzZXJVcHZvdGVkIiwiZ2V0VXNlclZvdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/db.ts\n"));

/***/ })

});